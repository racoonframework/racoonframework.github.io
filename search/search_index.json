{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Racoon","text":"<p>Racoon is a fast, fully customizable web framework for Rust focusing on simplicity.</p> <p>To use Racoon, you need minimal Rust version <code>1.76.0</code> and <code>Tokio</code> runtime.</p> <p>Read getting started guide</p>"},{"location":"cookies/","title":"Cookies","text":"<p>Racoon provides interface to access cookies from the <code>Request</code> instance. To set cookie, call <code>set_cookie()</code> method of the <code>Response</code> instance.</p> <p>The <code>set_cookie</code> method sets <code>HttpOnly</code> cookie with the <code>path=/</code>.</p>"},{"location":"cookies/#basic-usage","title":"Basic Usage","text":"<pre><code>use racoon::core::request::Request;\nuse racoon::core::response::status::ResponseStatus;\nuse racoon::core::response::{HttpResponse, Response};\n\nuse racoon::core::shortcuts::SingleText;\n\nasync fn home(request: Request) -&gt; Response {\n    // Reads cookie from request\n    let cookies = request.cookies;\n    println!(\"{:?}\", cookies.value(\"sessionid\"));\n\n    let mut response = HttpResponse::ok().body(\"Hello World\");\n    // Sets new sessionid cookie\n    response.set_cookie(\"sessionid\", \"123\", Duration::from_secs(86400));\n\n    // To remove cookie uncomment\n    // response.remove_cookie(\"sessionid\");\n    response\n}\n</code></pre> <p><code>request.cookies</code> is a <code>HashMap</code> and implements <code>SingleText</code> trait.</p>"},{"location":"form-validation/","title":"Form Validation","text":"<p>Racoon provides flexible way to validate your forms. You need to import fields from <code>racoon::forms::fields</code> module.</p> <p>The available fields are:</p> <ul> <li> <p>InputField</p> <ul> <li>InputField&lt;String&gt;</li> <li>InputField&lt;Option&lt;String&gt;&gt;</li> <li>InputField&lt;Vec&lt;String&gt;&gt;</li> <li>InputField&lt;Option&lt;Vec&lt;String&gt;&gt;</li> </ul> </li> <li> <p>FileField</p> <ul> <li>FileField&lt;UploadedFile&gt;</li> <li>FileField&lt;Option&lt;UploadedFile&gt;&gt;</li> <li>FileField&lt;Vec&lt;UploadedFile&gt;&gt;</li> <li>FileField&lt;Option&lt;Vec&lt;UploadedFile&gt;&gt;&gt;</li> </ul> </li> <li> <p>UuidField</p> <ul> <li>UuidField&lt;Uuid&gt;</li> <li>UuidField&lt;Option&lt;Uuid&gt;&gt;</li> <li>UuidField&lt;Vec&lt;Uuid&gt;&gt;</li> <li>UuidField&lt;Option&lt;Uuid&gt;&gt;</li> </ul> </li> </ul>"},{"location":"form-validation/#define-form-fields","title":"Define form fields","text":"<p>Create new struct and define your form fields.</p> <pre><code>use racoon::forms::fields::file_field::{FileField, UploadedFile};\nuse racoon::forms::fields::input_field::InputField;\nuse racoon::forms::FormFields;\n\nstruct UploadForm {\n    name: InputField&lt;String&gt;,\n    address: InputField&lt;Option&lt;String&gt;&gt;,\n    profile_photo: FileField&lt;UploadedFile&gt;,\n}\n</code></pre>"},{"location":"form-validation/#implement-formvalidator-trait","title":"Implement FormValidator trait","text":"<p>The form field takes <code>field_name</code> argument. </p> <pre><code>impl FormValidator for UploadForm {\n  fn new() -&gt; Self {\n    let name = InputField::new(\"name\");\n    let address = InputField::new(\"address\");\n    let profile_photo = FileField::new(\"profile\");\n\n    Self {\n        name,\n        address,\n        profile_photo,\n    }\n  }\n\n  fn form_fields(&amp;mut self) -&gt; FormFields {\n    // List here form fields\n    vec![\n        self.name.wrap(),\n        self.address.wrap(),\n        self.profile_photo.wrap(),\n    ]\n  }\n}\n</code></pre>"},{"location":"form-validation/#using-in-view","title":"Using in view","text":"<pre><code>async fn upload_profile(request: Request) -&gt; Response {\n    let form = UploadForm::new();\n    match form.validate(&amp;request).await {\n        Ok(form) =&gt; {\n            // Printing form values\n            println!(\"Name: {}\", form.name.value().await);\n            println!(\"Address: {:?}\", form.address.value().await);\n            println!(\"File Name: {}\", form.profile_photo.value().await.filename);\n            return HttpResponse::ok().body(\"Upload success\");\n        }\n        Err(error) =&gt; {\n            return HttpResponse::bad_request().body(format!(\"{:?}\", error.field_errors));\n        }\n    }\n}\n</code></pre>"},{"location":"form-validation/#custom-validation","title":"Custom validation","text":"<p>Add your custom validation logic inside the <code>post_validate()</code> method. It will only be called after field is validated with default constraints. Some fields may not have <code>post_validate()</code> method.</p> <pre><code>let name: InputField&lt;String&gt; = InputField::new(\"name\").post_validate(|value| {\n  if value.eq(\"default\") {\n     return Err(vec![\"Default value is selected\".to_string()]);\n  }\n  return Ok(value);\n});\n</code></pre>"},{"location":"form-validation/#custom-errors","title":"Custom errors","text":"<p>You can customize the error messages with<code>handle_error_message()</code> method.</p> <pre><code>let name: InputField&lt;String&gt; = InputField::new(\"name\").handle_error_message(|error, default_errors| {\n  match error {\n    InputFieldError::MissingField(field_name) =&gt; {\n      println!(\"Missing field name: {}\", field_name);\n      return vec![\"Custom field missing error\".to_string()];\n    }\n    _ =&gt; {}\n  }\n\n  // Returns default error messages\n  default_errors\n});\n</code></pre> <p>Checkout form constraints guide to know about default constraints applied by Racoon.</p>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#installation","title":"Installation","text":"<p>You will need <code>tokio</code> runtime to run Racoon. Run <code>cargo add tokio</code> to install tokio crate.</p> <pre><code>[dependencies]\nracoon = \"0.1.6\"\ntokio = \"1.18.5\"\n</code></pre>"},{"location":"getting-started/#hello-world","title":"Hello World","text":"<p>Racoon is fairly simple, you just define the function which takes <code>Request</code> and returns the <code>Response</code>. Once you define your function, define your routes, bind the server and you are ready to go.</p> <p>This is a simple example code which returns response \"Hello World\". Click on http://127.0.0.1:8080 to see the page.</p> <pre><code>use racoon::core::path::Path;\nuse racoon::core::request::Request;\nuse racoon::core::response::{HttpResponse, Response};\nuse racoon::core::response::status::ResponseStatus;\nuse racoon::core::server::Server;\n\nuse racoon::view;\n\nasync fn hello_world(request: Request) -&gt; Response {\n    HttpResponse::ok().body(\"Hello World\")\n}\n\n#[tokio::main]\nasync fn main() {\n    let paths = vec![\n        Path::new(\"/\", view!(hello_world))\n    ];\n\n    let result = Server::bind(\"127.0.0.1:8080\")\n        .urls(paths)\n        .run().await;\n\n    println!(\"Failed to run server: {:?}\", result);\n}\n</code></pre> <p>For more binding options such as Unix Domain Sockets or with TLS, checkout server binding options guide.</p>"},{"location":"middleware/","title":"Middleware","text":"<p>The middleware can run before processing the response and after the response.</p> <p>You can perform task like logging, serving static files or security checks inside the <code>wrap</code> middleware  function.</p>"},{"location":"middleware/#basic-usage","title":"Basic Usage","text":"<p>You need to use <code>wrap_view!</code> macro to wrap async middleware view.</p> <pre><code>use racoon::core::path::{Path, View};\nuse racoon::core::request::Request;\nuse racoon::core::response::{HttpResponse, Response};\nuse racoon::core::response::status::ResponseStatus;\nuse racoon::core::server::Server;\n\nuse racoon::{view, wrap_view};\n\nasync fn middleware(mut request: Request, view: Option&lt;View&gt;) -&gt; Response {\n    if request.path == \"/old\" {\n        return HttpResponse::temporary_redirect().location(\"/new\");\n    }\n\n    Path::resolve(request, view).await\n}\n\nasync fn hello_world(request: Request) -&gt; Response {\n    HttpResponse::ok().body(\"Hello World\")\n}\n\n#[tokio::main]\nasync fn main() {\n    let paths = vec![\n        Path::new(\"/\", view!(hello_world))\n    ];\n\n    let _ = Server::bind(\"127.0.0.1:8080\")\n        .wrap(wrap_view!(middleware)) // Wrap middleware\n        .urls(paths)\n        .run().await;\n}\n</code></pre>"},{"location":"reading-form-data/","title":"Handling forms","text":"<p>Racoon currently supports <code>multipart/form-data</code> and <code>application/x-www-form-urlencoded</code>. If you require to read the body of another content type you can use <code>request.stream</code> to read the  request body manually.</p>"},{"location":"reading-form-data/#basic-usage","title":"Basic Usage","text":"<p>The <code>FormData</code> and <code>File</code> are the HashMap instances.</p> <pre><code>use racoon::core::path::{Path, View};\nuse racoon::core::request::Request;\nuse racoon::core::response::{HttpResponse, Response};\nuse racoon::core::response::status::ResponseStatus;\nuse racoon::core::server::Server;\nuse racoon::core::forms::FileField;\nuse racoon::core::shortcuts::SingleText;\n\nuse racoon::{view, wrap_view};\n\n\nasync fn form(request: Request) -&gt; Response {\n    if request.method == \"POST\" {\n        // Parses request body\n        let (form_data, files) = request.parse().await;\n        println!(\"Name: {:?}\", form_data.value(\"name\"));\n\n        let file = files.value(\"file\");\n        println!(\"File: {:?}\", file);\n        return HttpResponse::ok().body(\"Uploaded\");\n    }\n\n    HttpResponse::bad_request().body(\"Failed\")\n}\n\n#[tokio::main]\nasync fn main() {\n    let paths = vec![\n        Path::new(\"/form/\", view!(form))\n    ];\n\n    let _ = Server::bind(\"127.0.0.1:8080\")\n        .urls(paths)\n        .run().await;\n}\n</code></pre> <p>Checkout form constraints guide to know about default constraints applied by Racoon.</p>"},{"location":"response/","title":"Response","text":"<p>Racoon supports <code>text/html</code> and <code>application/json</code> with <code>HttpResponse</code> and <code>JsonResponse</code> structs.</p>"},{"location":"response/#http-response","title":"HTTP Response","text":"<pre><code>use racoon::core::request::Request;\nuse racoon::core::response::{HttpResponse, Response};\n\nasync fn hello_world(request: Request) -&gt; Response {\n    HttpResponse::ok().body(\"Hello World\")\n}\n</code></pre>"},{"location":"response/#json-response","title":"JSON Response","text":"<p>To use Json Response, you need to add <code>serde_json</code> crate.</p> <pre><code>use racoon::core::request::Request;\nuse racoon::core::request::Request;\nuse racoon::core::response::{JsonResponse, Response};\n\nasync fn hello_world(request: Request) -&gt; Response {\n    JsonResponse::ok().body(json!({\n        \"content\": \"Hello World\"\n    }))\n}\n</code></pre>"},{"location":"response/#custom-response","title":"Custom Response","text":"<p>You can write your own custom Response type by implementing <code>AbstractResponse</code> trait.</p> <pre><code>struct CustomResponse;\n\nimpl AbstractResponse for CustomResponse {\n    fn status(&amp;self) -&gt; (u32, String) {\n        todo!()\n    }\n\n    fn serve_default(&amp;mut self) -&gt; bool {\n        todo!()\n    }\n\n    fn get_headers(&amp;mut self) -&gt; &amp;mut Headers {\n        todo!()\n    }\n\n    fn get_body(&amp;mut self) -&gt; &amp;mut Vec&lt;u8&gt; {\n        todo!()\n    }\n\n    fn should_close(&amp;mut self) -&gt; bool {\n        todo!()\n    }\n}\n</code></pre>"},{"location":"routing/","title":"Routing","text":"<p>Racoon uses matchit crate internally to handle routing and extract path parts. </p> <p>You can access the <code>query_params</code> and <code>path_params</code> from the request instance.</p>"},{"location":"routing/#example","title":"Example","text":"<p>You need to use <code>view!</code> macro to wrap your async views.</p> <p><pre><code>use racoon::core::path::Path;\nuse racoon::core::request::Request;\nuse racoon::core::response::{HttpResponse, Response};\nuse racoon::core::response::status::ResponseStatus;\nuse racoon::core::server::Server;\nuse racoon::core::shortcuts::SingleText;\n\nuse racoon::view;\n\nasync fn hello_world(request: Request) -&gt; Response {\n    println!(\"{:?}\", request.query_params.value(\"name\"));\n    println!(\"{:?}\", request.path_params.value(\"id\"));\n    HttpResponse::ok().body(\"Hello World\")\n}\n\n#[tokio::main]\nasync fn main() {\n    let paths = vec![\n        Path::new(\"/\", view!(hello_world)),\n        Path::new(\"/{id}/\", view!(hello_world)),\n    ];\n\n    let _ = Server::bind(\"127.0.0.1:8080\")\n        .urls(paths) // Pass urls here\n        .run().await;\n}\n</code></pre> To know more about pattern matching, please read the matchit documentation.</p>"},{"location":"server-binding-options/","title":"Server binding options","text":"<p>Racoon provides multiple ways to bind server which allows you to have low level controls.</p>"},{"location":"server-binding-options/#binding-to-host-port-number","title":"Binding to host port number","text":"<pre><code>#[tokio::main]\nasync fn main() {\n    let result = Server::bind(\"127.0.0.1:8080\").urls(...).run().await;\n    println!(\"Failed to run server: {:?}\", result);\n}\n</code></pre>"},{"location":"server-binding-options/#binding-to-unix-domain-socket","title":"Binding to Unix Domain Socket","text":"<pre><code>#[tokio::main]\nasync fn main() {\n    let result = Server::bind_uds(\"tmp.sock\").urls.run().await;\n    println!(\"Failed to run server: {:?}\", result);\n}\n</code></pre>"},{"location":"server-binding-options/#binding-to-tls","title":"Binding to TLS","text":"<pre><code>#[tokio::main]\nasync fn main() {\n    let result = Server::bind_tls(\"0.0.0.0:443\", \"../cert.pem\", \"../key.pem\")\n        .unwrap()\n        .urls(paths)\n        .run()\n        .await;\n    println!(\"Failed to run server: {:?}\", result);\n}\n</code></pre>"},{"location":"server-binding-options/#custom-binding-to-tls","title":"Custom binding to TLS","text":"<pre><code>use racoon::core::server::utils;\n\n#[tokio::main]\nasync fn main() {\n    let tls_acceptor = utils::tls_acceptor_from_path(\"../cert.pem\", \"../key.pem\").unwrap();\n\n    let tcp_listener = TcpListener::bind(\"0.0.0.0:443\").await.unwrap();\n    let result = Server::bind_tls_custom(tcp_listener, tls_acceptor)\n        .urls(...)\n        .run()\n        .await;\n    println!(\"Failed to run server: {:?}\", result);\n}\n</code></pre>"},{"location":"server-binding-options/#binding-from-tcplistener","title":"Binding from TcpListener","text":"<pre><code>#[tokio::main]\nasync fn main() {\n    let tcp_listener = TcpListener::bind(\"0.0.0.0:443\").await.unwrap();\n    let result = Server::from_tcp_listener(tcp_listener)\n            .urls(...)\n            .run()\n            .await;\n    println!(\"Failed to run server: {:?}\", result);\n</code></pre>"},{"location":"server-binding-options/#binding-from-unixlistener","title":"Binding from UnixListener","text":"<pre><code>#[tokio::main]\nasync fn main() {\n    let unix_listener = UnixListener::bind(\"tmp.sock\").unwrap();\n    let result = Server::from_unix_listener(unix_listener)\n            .urls(paths)\n            .run()\n            .await;\n    println!(\"Failed to run server: {:?}\", result);\n}\n</code></pre>"},{"location":"server-configurations/","title":"Server configurations","text":""},{"location":"server-configurations/#buffer-size","title":"Buffer size","text":"<p>The default buffer size to read/write from stream is <code>8096</code> bytes. You can specify buffer size in the <code>Server</code> instance.</p> <pre><code>let server = Server::bind(\"127.0.0.1:8080\").buffer_size(4094).urls(...).run().await;\n</code></pre>"},{"location":"server-configurations/#form-constraints","title":"Form constraints","text":"<p>These constraints are automatically applied when you call <code>request.parse()</code> method.</p> <pre><code>// These form constraints are the default form constraints used while parsing form body.\n// Modify according to your need. All size are in bytes.\nlet form_constraints = FormConstraints::new(\n    512 * 1024 * 1024, // Max body size\n    2 * 1024 * 1024, // Max header size \n    512 * 1024 * 1024, // Max file size\n    2 * 1024 * 1024, // Max text value size\n    HashMap::new() // Field sizes by their names\n);\n\nlet server = Server::bind(\"127.0.0.1:8080\")\n    .form_constraints(form_constraints)\n    .urls(...)\n    .run()\n    .await;\n</code></pre>"},{"location":"server-configurations/#request-constraints","title":"Request constraints","text":"<p>These constraints are automatically applied while reading incoming requests from the client. This will return <code>Request Header Field Too Large</code> status response if header size is too large than the size specified in constraint.</p> <pre><code>// These request constraints are used while reading requests header.\nlet request_constraints = RequestConstraints {\n    max_request_header_size: 5 * 1024 * 1024, // Maximum allowed header size in bytes\n    max_header_count: 100, // Maximum number of headers allowed\n};\n\nlet server = Server::bind(\"127.0.0.1:8080\")\n    .request_constraints(request_constraints)\n    .urls(...)\n    .run()\n    .await;\n</code></pre>"},{"location":"server-configurations/#tcp-nodelay","title":"TCP Nodelay","text":"<p>To set nodelay for socket client streams, use <code>server.nodelay()</code> method. This configuration will do nothing  if you are using Unix Domain Socket.</p> <pre><code>let server = Server::bind(\"127.0.0.1:8080\")\n        .request_constraints(request_constraints)\n        .nodelay() // Set nodelay\n        .urls(...)\n        .run()\n        .await;\n</code></pre>"},{"location":"session/","title":"Session","text":"<p>Racoon provides interface to access session values from the <code>Request</code> instance. By default, racoon uses <code>FileSessionManager</code> for managing and storing the session data.</p> <p><code>FileSessionManager</code> uses Sqlite database and it is lazily created at <code>.cache/session</code> when for the first time <code>session.set()</code> is invoked.</p>"},{"location":"session/#basic-usage","title":"Basic Usage","text":"<pre><code>use racoon::core::path::Path;\nuse racoon::core::request::Request;\nuse racoon::core::response::status::ResponseStatus;\nuse racoon::core::response::{HttpResponse, Response};\n\nuse racoon::core::server::Server;\nuse racoon::view;\n\nasync fn home(request: Request) -&gt; Response {\n    let session = request.session;\n    let name = session.get(\"Hello World\").await;\n    // Reads session value\n    println!(\"name: {:?}\", name);\n\n    let _ = session.set(\"location\", \"Ktm\").await;\n\n    // Removes session value\n    let _ = session.remove(\"name\").await;\n\n    // Destory session\n    let _ = session.destroy().await;\n\n    HttpResponse::ok().body(\"Hello World\")\n}\n</code></pre>"},{"location":"session/#custom-session-manager","title":"Custom session manager","text":"<p>To create custom session manager, you need to implement <code>AbstractSessionManager</code> trait from the <code>racoon::core::session</code> module.</p> <pre><code>struct RedisSessionManager;\n\nimpl AbstractSessionManager for RedisSessionManager {\n        fn set(\n        &amp;self,\n        session_id: &amp;String,\n        name: &amp;str,\n        value: &amp;str,\n    ) -&gt; SessionResult&lt;std::io::Result&lt;()&gt;&gt; {\n        todo!()\n    }\n\n    fn get(&amp;self, session_id: &amp;String, name: &amp;str) -&gt; SessionResult&lt;Option&lt;String&gt;&gt; {\n        todo!()\n    }\n\n    fn remove(&amp;self, session_id: &amp;String, name: &amp;str) -&gt; SessionResult&lt;std::io::Result&lt;()&gt;&gt; {\n        todo!()\n    }\n\n    fn destroy(&amp;self, session_id: &amp;String) -&gt; SessionResult&lt;std::io::Result&lt;()&gt;&gt; {\n        todo!()\n    }\n}\n\n\n#[tokio::main]\nasync fn main() {\n    let paths = vec![Path::new(\"/\", view!(home))];\n\n    let custom_session_manager = RedisSessionManager {};\n    let result = Server::bind(\"127.0.0.1:8080\")\n            .urls(paths)\n            .set_session_manager(custom_session_manager) // Set your custom session manager here\n            .run()\n            .await;\n    println(\"{:?}\", result);\n}\n</code></pre>"},{"location":"shared-context/","title":"Shared Context","text":"<p>Shared context is useful when you need to access the states, instances such as database connection,  websocket clients etc. in views.</p>"},{"location":"shared-context/#example","title":"Example","text":"<pre><code>use racoon::core::path::Path;\nuse racoon::core::request::Request;\nuse racoon::core::response::{HttpResponse, Response};\nuse racoon::core::response::status::ResponseStatus;\nuse racoon::core::server::Server;\n\nuse racoon::view;\n\npub struct SharedContext {\n    pub max_connections: u32,\n}\n\n\nasync fn hello_world(mut request: Request) -&gt; Response {\n    // Access shared context\n    let context = request.context::&lt;SharedContext&gt;().unwrap();\n    println!(\"Max connections: {}\", context.max_connections);\n    HttpResponse::ok().body(\"Hello World\")\n}\n\n#[tokio::main]\nasync fn main() {\n    let paths = vec![\n        Path::new(\"/\", view!(hello_world))\n    ];\n\n    let _ = Server::bind(\"127.0.0.1:8080\")\n        .context(SharedContext { max_connections: 10 })\n        .urls(paths)\n        .run().await;\n}\n</code></pre>"},{"location":"stopping-server/","title":"Stopping server","text":"<p>Racoon uses Mutex and CondVar to hold the shutdown lock.  To release the shutdown lock, clone the mutex from <code>Server</code> instance.</p>"},{"location":"stopping-server/#example","title":"Example","text":"<pre><code>let mut server = Server::bind(\"127.0.0.1:8080\");\nlet lock = server.shutdown_lock();\n\n// Automatically shutdown after 1 minutes\ntokio::spawn(async move {\n    let (_, condvar) = &amp;*lock;\n    condvar.notify_all(); // Releases shutdown lock\n});\n\n_ = server.run().await;\n</code></pre>"},{"location":"websocket-basics/","title":"WebSocket","text":"<p>Using websocket with Racoon is easy. You need to create <code>WebSocket</code> instance, loop incoming message and return the exit response.</p> <p>To clone websocket instance for group chats, use <code>websocket.clone()</code>. This clone is thread safe and uses the same underlying connection.</p>"},{"location":"websocket-basics/#basic-usage","title":"Basic Usage","text":"<pre><code>use racoon::core::path::Path;\nuse racoon::core::request::Request;\nuse racoon::core::response::Response;\nuse racoon::core::server::Server;\nuse racoon::core::websocket::{Message, WebSocket};\n\nuse racoon::view;\n\nasync fn ws(request: Request) -&gt; Response {\n    let (websocket, connected) = WebSocket::from(&amp;request).await;\n    if !connected {\n        // WebSocket connection didn't success\n        return websocket.bad_request().await;\n    }\n\n    println!(\"WebSocket client connected.\");\n\n    // Receive incoming messages\n    while let Some(message) = websocket.message().await {\n        match message {\n            Message::Text(text) =&gt; {\n                println!(\"Message: {}\", text);\n\n                // Sends received message back\n                let _ = websocket.send_text(text.as_str()).await;\n            }\n            _ =&gt; {}\n        }\n    }\n    websocket.exit()\n}\n\n#[tokio::main]``\nasync fn main() {\n    let paths = vec![\n        Path::new(\"/ws/\", view!(ws))\n    ];\n\n    let _ = Server::bind(\"127.0.0.1:8080\")\n        .urls(paths)\n        .run().await;\n}\n</code></pre> <p>You can also send directly JSON text with <code>websocket.send_json(&amp;json!({\"content\": \"123\"})).await</code>. For this, you will need to add <code>serde_json</code> crate in <code>Cargo.toml</code>.</p>"}]}